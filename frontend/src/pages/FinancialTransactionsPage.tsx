import React, { useEffect, useMemo, useState } from 'react';
import { ArrowUpDown, Plus } from 'lucide-react';
import { useNavigate } from 'react-router-dom';
import { apiClient } from '@/services/api';
import { Alert, Badge, Button, Card, Input, Loading, Modal, Select } from '@/components/common';
import type { FinancialCategory, FinancialTransaction } from '@/types';
import './FinancialTransactionsPage.css';

const STATUS_LABEL: Record<FinancialTransaction['status'], string> = {
  pending: 'Pendente',
  paid: 'Pago',
  cancelled: 'Cancelado',
  overdue: 'Vencido',
};

const STATUS_VARIANT: Record<FinancialTransaction['status'], any> = {
  pending: 'warning',
  paid: 'success',
  cancelled: 'danger',
  overdue: 'danger',
};

const TYPE_LABEL: Record<FinancialTransaction['transactionType'], string> = {
  revenue: 'Receita',
  expense: 'Despesa',
  transfer: 'Transferência',
};

const formatMoney = (value: any) => {
  const n = Number(value);
  if (!Number.isFinite(n)) return String(value ?? '-');
  return n.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' });
};

const todayISO = () => new Date().toISOString().slice(0, 10);
const daysAgoISO = (days: number) => {
  const d = new Date();
  d.setDate(d.getDate() - days);
  return d.toISOString().slice(0, 10);
};

const isFromAccountsPayableOrReceivable = (t: FinancialTransaction) => {
  const ref = String(t.referenceNumber ?? '');
  const desc = String(t.description ?? '').trim().toLowerCase();

  // Patterns generated by Accounts Payable / Receivable services
  if (ref.startsWith('PAYMENT-') || ref.startsWith('RECEIPT-')) return true;

  // Fallback detection by description prefix
  if (desc.startsWith('conta a pagar:') || desc.startsWith('pagamento:')) return true;
  if (desc.startsWith('conta a receber:') || desc.startsWith('recebimento:')) return true;

  return false;
};

const looksLikeUuid = (value: string) =>
  /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(value);

const getOriginTarget = (t: FinancialTransaction): { path: string; id?: string } | null => {
  const ref = String(t.referenceNumber ?? '');
  const desc = String(t.description ?? '').trim().toLowerCase();

  if (ref.startsWith('PAYMENT-')) {
    const id = ref.slice('PAYMENT-'.length);
    return { path: '/financial/accounts-payable', ...(id ? { id } : {}) };
  }

  if (ref.startsWith('RECEIPT-')) {
    const id = ref.slice('RECEIPT-'.length);
    return { path: '/financial/accounts-receivable', ...(id ? { id } : {}) };
  }

  if (desc.startsWith('conta a pagar:') || desc.startsWith('pagamento:')) {
    return { path: '/financial/accounts-payable', ...(looksLikeUuid(ref) ? { id: ref } : {}) };
  }

  if (desc.startsWith('conta a receber:') || desc.startsWith('recebimento:')) {
    return { path: '/financial/accounts-receivable', ...(looksLikeUuid(ref) ? { id: ref } : {}) };
  }

  return null;
};

export const FinancialTransactionsPage: React.FC = () => {
  const navigate = useNavigate();

  const [categories, setCategories] = useState<FinancialCategory[]>([]);
  const [transactions, setTransactions] = useState<FinancialTransaction[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [success, setSuccess] = useState<string | null>(null);

  const [filters, setFilters] = useState({
    categoryId: '',
    transactionType: '',
    status: '',
    startDate: daysAgoISO(30),
    endDate: todayISO(),
  });

  const [isCreateOpen, setIsCreateOpen] = useState(false);
  const [createForm, setCreateForm] = useState({
    categoryId: '',
    transactionType: 'expense' as FinancialTransaction['transactionType'],
    amount: '',
    description: '',
    transactionDate: todayISO(),
    dueDate: '',
  });

  const loadCategories = async () => {
    const response = await apiClient.getFinancialCategories(true);
    const list = response.data || response;
    setCategories(list);
  };

  const loadTransactions = async () => {
    const response = await apiClient.searchFinancialTransactions({
      ...(filters.categoryId ? { categoryId: filters.categoryId } : {}),
      ...(filters.transactionType ? { transactionType: filters.transactionType } : {}),
      ...(filters.status ? { status: filters.status } : {}),
      ...(filters.startDate ? { startDate: filters.startDate } : {}),
      ...(filters.endDate ? { endDate: filters.endDate } : {}),
      page: 1,
      limit: 50,
    });

    const list = response.data || response;
    setTransactions(list);
  };

  const load = async () => {
    try {
      setLoading(true);
      await Promise.all([loadCategories(), loadTransactions()]);
    } catch {
      setError('Erro ao carregar transações');
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    load();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  const categoryOptions = useMemo(() => {
    return categories.map((c) => ({ value: c.id, label: c.name }));
  }, [categories]);

  const categoryNameById = useMemo(() => {
    const map = new Map<string, string>();
    categories.forEach((c) => map.set(c.id, c.name));
    return map;
  }, [categories]);

  const openCreate = () => {
    setError(null);
    setSuccess(null);
    setCreateForm({
      categoryId: categories[0]?.id || '',
      transactionType: 'expense',
      amount: '',
      description: '',
      transactionDate: todayISO(),
      dueDate: '',
    });
    setIsCreateOpen(true);
  };

  const handleCreate = async (e: React.FormEvent) => {
    e.preventDefault();
    setError(null);
    setSuccess(null);

    try {
      await apiClient.createFinancialTransaction({
        categoryId: createForm.categoryId,
        transactionType: createForm.transactionType,
        amount: Number(createForm.amount),
        description: createForm.description,
        transactionDate: createForm.transactionDate,
        dueDate: createForm.dueDate || undefined,
      });
      setIsCreateOpen(false);
      setSuccess('Transação criada com sucesso');
      setTimeout(() => setSuccess(null), 2500);
      await loadTransactions();
    } catch (err: any) {
      setError(err.response?.data?.message || 'Erro ao criar transação');
    }
  };

  const handleMarkPaid = async (id: string) => {
    setError(null);
    try {
      await apiClient.markFinancialTransactionPaid(id);
      await loadTransactions();
    } catch (err: any) {
      setError(err.response?.data?.message || 'Erro ao marcar como paga');
    }
  };

  const handleCancel = async (id: string) => {
    const reason = window.prompt('Motivo do cancelamento:');
    if (!reason) return;
    setError(null);
    try {
      await apiClient.cancelFinancialTransaction(id, reason);
      await loadTransactions();
    } catch (err: any) {
      setError(err.response?.data?.message || 'Erro ao cancelar');
    }
  };

  return (
    <div className="financial-transactions-page">
      <div className="financial-transactions-header">
        <div className="page-header">
          <ArrowUpDown size={28} />
          <h1>Transações</h1>
        </div>
        <div className="financial-transactions-header-actions">
          <Button variant="secondary" onClick={() => loadTransactions()}>
            Buscar
          </Button>
          <Button onClick={openCreate}>
            <Plus size={16} />
            Nova transação
          </Button>
        </div>
      </div>

      <Card className="financial-transactions-filters">
        <div className="financial-transactions-filters-grid">
          <Select
            label="Categoria"
            value={filters.categoryId}
            onChange={(e) => setFilters((p) => ({ ...p, categoryId: e.target.value }))}
            options={[{ value: '', label: 'Todas' }, ...categoryOptions]}
          />
          <Select
            label="Tipo"
            value={filters.transactionType}
            onChange={(e) => setFilters((p) => ({ ...p, transactionType: e.target.value }))}
            options={[
              { value: '', label: 'Todos' },
              { value: 'revenue', label: 'Receita' },
              { value: 'expense', label: 'Despesa' },
              { value: 'transfer', label: 'Transferência' },
            ]}
          />
          <Select
            label="Status"
            value={filters.status}
            onChange={(e) => setFilters((p) => ({ ...p, status: e.target.value }))}
            options={[
              { value: '', label: 'Todos' },
              { value: 'pending', label: 'Pendente' },
              { value: 'paid', label: 'Pago' },
              { value: 'overdue', label: 'Vencido' },
              { value: 'cancelled', label: 'Cancelado' },
            ]}
          />
          <Input
            label="Data inicial"
            type="date"
            value={filters.startDate}
            onChange={(e) => setFilters((p) => ({ ...p, startDate: e.target.value }))}
          />
          <Input
            label="Data final"
            type="date"
            value={filters.endDate}
            onChange={(e) => setFilters((p) => ({ ...p, endDate: e.target.value }))}
          />
        </div>
      </Card>

      {error && (
        <Alert variant="danger" onClose={() => setError(null)}>
          {error}
        </Alert>
      )}
      {success && (
        <Alert variant="success" onClose={() => setSuccess(null)}>
          {success}
        </Alert>
      )}

      {loading ? (
        <Loading message="Carregando transações..." />
      ) : (
        <div className="financial-transactions-table-wrapper">
          <table className="financial-transactions-table">
            <thead>
              <tr>
                <th>Data</th>
                <th>Categoria</th>
                <th>Tipo</th>
                <th>Descrição</th>
                <th>Valor</th>
                <th>Status</th>
                <th className="financial-transactions-right">Ações</th>
              </tr>
            </thead>
            <tbody>
              {transactions.map((t) => (
                <tr key={t.id}>
                  <td>{String(t.transactionDate).slice(0, 10)}</td>
                  <td>{t.category?.name || categoryNameById.get(t.categoryId) || '-'}</td>
                  <td className="financial-transactions-muted">{TYPE_LABEL[t.transactionType]}</td>
                  <td>{t.description}</td>
                  <td className="financial-transactions-money">{formatMoney(t.amount)}</td>
                  <td>
                    <Badge variant={STATUS_VARIANT[t.status]}>{STATUS_LABEL[t.status]}</Badge>
                  </td>
                  <td className="financial-transactions-right">
                    <div className="financial-transactions-actions">
                      {isFromAccountsPayableOrReceivable(t) && (
                        <Button
                          size="sm"
                          variant="secondary"
                          onClick={() => {
                            const origin = getOriginTarget(t);
                            if (!origin) return;
                            navigate(origin.id ? `${origin.path}?id=${encodeURIComponent(origin.id)}` : origin.path);
                          }}
                        >
                          Ver origem
                        </Button>
                      )}
                      {t.status !== 'paid' && t.status !== 'cancelled' && !isFromAccountsPayableOrReceivable(t) && (
                        <Button size="sm" variant="success" onClick={() => handleMarkPaid(t.id)}>
                          Pagar
                        </Button>
                      )}
                      {t.status !== 'cancelled' && (
                        <Button size="sm" variant="danger" onClick={() => handleCancel(t.id)}>
                          Cancelar
                        </Button>
                      )}
                    </div>
                  </td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      )}

      <Modal
        isOpen={isCreateOpen}
        title="Nova transação"
        onClose={() => setIsCreateOpen(false)}
        footer={
          <div className="financial-transactions-modal-footer">
            <Button variant="secondary" onClick={() => setIsCreateOpen(false)}>
              Cancelar
            </Button>
            <Button onClick={handleCreate as any}>Salvar</Button>
          </div>
        }
      >
        <form onSubmit={handleCreate} className="financial-transactions-form">
          <Select
            label="Categoria"
            value={createForm.categoryId}
            onChange={(e) => setCreateForm((p) => ({ ...p, categoryId: e.target.value }))}
            options={categoryOptions}
          />
          <Select
            label="Tipo"
            value={createForm.transactionType}
            onChange={(e) => setCreateForm((p) => ({ ...p, transactionType: e.target.value as any }))}
            options={[
              { value: 'expense', label: 'Despesa' },
              { value: 'revenue', label: 'Receita' },
              { value: 'transfer', label: 'Transferência' },
            ]}
          />
          <Input
            label="Valor"
            type="number"
            step="0.01"
            min={0}
            value={createForm.amount}
            onChange={(e) => setCreateForm((p) => ({ ...p, amount: e.target.value }))}
            required
          />
          <Input
            label="Descrição"
            value={createForm.description}
            onChange={(e) => setCreateForm((p) => ({ ...p, description: e.target.value }))}
            required
          />
          <Input
            label="Data"
            type="date"
            value={createForm.transactionDate}
            onChange={(e) => setCreateForm((p) => ({ ...p, transactionDate: e.target.value }))}
            required
          />
          <Input
            label="Vencimento (opcional)"
            type="date"
            value={createForm.dueDate}
            onChange={(e) => setCreateForm((p) => ({ ...p, dueDate: e.target.value }))}
          />
        </form>
      </Modal>
    </div>
  );
};
